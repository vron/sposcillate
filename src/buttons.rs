// Module to handle de-bounding of button presses and convert the states of them
// to more high-level events "click", "double click" and press events.
// The module is currently specialized for 4 buttons specifically but written such that
// all the code should be generated by a macro allowing th user to instansiate it
// with the desired number of buttons for a particular case / board

// TODO: WHEN MAKING INTO MACRO, ONLY ACCEPT 16 BUTTONS - SINCE THATS THE TYPE WE USE

use core::{hint::unlikely};

use embedded_hal::digital::InputPin;

use crate::{timer::{self, MilliSeconds}};

pub type Button = u8;

pub enum ButtonEvent {
    // Represents a single click on a button, note that since we want to also support
    // double clicks and presses etc. the event will be generated when the button is
    // released - and only if a press event was not genereated.
    Click{btn: Button, mods: Modifiers},
    // Represents that the user has clicked and pressed the given button and that it is
    // millis since the button was first pressed (allow to e.g. increase speed after a
    // certian time).
    Press{btn: Button, millis: u32, mods: Modifiers}
}

// Represents the state of other buttons on a click event, i.e. in particular
// if other buttons where held simulataniously.
pub struct Modifiers(u16);

impl Modifiers {
    pub fn pressed(&self, other: Button) -> bool {
        let masked = self.0 & (other as u16);
        masked != 0
    }

    // True if there is currently no button pressed
    pub fn empty(&self) ->bool {
        self.0 == 0
    }
}



pub struct Buttons<B0, B1, B2, B3, const T_READ: u32, const T_NOICE: u32, const T_PRESS: u32> {
    // The event buffer used to return multiple events
    buffer: [ButtonEvent; 4],

    // The pins used for the buttons
    b0: B0,
    b1: B1,
    b2: B2,
    b3: B3,

    // The states of the buttons (pressed, pressStart, is_press)
    s0: (bool, timer::MilliSeconds, bool),
    s1: (bool, timer::MilliSeconds, bool),
    s2: (bool, timer::MilliSeconds, bool),
    s3: (bool, timer::MilliSeconds, bool),

    // Store if nothing was pressed last time
    nothing_pressed: bool,
    // The last time we read the input
    last_read: timer::MilliSeconds,
}

impl<B0, B1, B2, B3, const T_READ: u32, const T_NOICE: u32, const T_PRESS: u32> Buttons<B0, B1, B2, B3, T_READ, T_NOICE, T_PRESS> where 
B0: InputPin,
B1: InputPin,
B2: InputPin,
B3: InputPin,

{
    pub fn new(b0: B0, b1:B1, b2:B2, b3: B3) -> Self {
        Self {
            buffer: Default::default(),
            b0,b1,b2,b3,
            s0: (false, MilliSeconds::default(), false),
            s1: (false, MilliSeconds::default(), false),
            s2: (false, MilliSeconds::default(), false),
            s3: (false, MilliSeconds::default(), false),
            nothing_pressed: true,
            last_read: MilliSeconds::default(),
        }
    }

    // Fast function that is intended to be run regularly in the main application loop. The millis argument
    // should be provided with a numbber of milli secons since startup of the program, it's fine
    // if it overflows after a while.
    // Note that it scales linearly with the number of buttons where the user interacts
    pub fn run(&mut self, millis: MilliSeconds) -> &[ButtonEvent] {
        // Avoid reading all the input pins all the time
        if  !(millis - self.last_read > T_READ) {
            return &[]
        }

        // Read all the input pins
        let mods =
            u16::from(self.b0.is_high().unwrap_or_default()) << 0 |
            u16::from(self.b1.is_high().unwrap_or_default()) << 1 |
            u16::from(self.b2.is_high().unwrap_or_default()) << 2 |
            u16::from(self.b3.is_high().unwrap_or_default()) << 3;
        self.last_read = millis;

        // We create a fast-path that will commonly be taken, if nothing was pressed last time
        // and nothing is pressed this time there is nothing to do so simply return
        if self.nothing_pressed && mods == 0 {
            return &[]
        }
        self.nothing_pressed = mods == 0;

        // This array really only is for us to be able to use a loop below, hopefully
        // the compiler is smart enough to replace it by offsets into self..
        let last = [
            &mut self.s0,
            &mut self.s1,
            &mut self.s2,
            &mut self.s3,
        ];

        // Keep track of how many events we should return
        let mut no_events= 0;

        for i in 0..4 {
            let now = (mods & (1 << (i as u16))) != 0;
            let last_time = &mut last[i].1;
            let is_press = &mut last[i].2;
            let last = &mut last[i].0;

            // Most often we should not have to do anything for a particulat button
            if unlikely(*last || now) {
                match (*last, now) {
                    (false, false) => {}
                    (false, true) => {
                        // The button was not pressed last time but pressed this time, so
                        // record it as the start of a potential click
                        *last_time = millis;
                        *last = true;
                        *is_press = false;
                        },
                    (true, false) => {
                        // This is a potential click, procided we did not long-press (in which case None)
                        // or the click was so short that we do not believe it was a real click but only
                        // some noice on the channel that we ignore.
                        if !*is_press {
                            if  millis - *last_time >= T_NOICE {
                                self.buffer[no_events] = ButtonEvent::Click{btn: i as Button, mods: Modifiers(mods)};
                                no_events += 1;
                            }
                        }
                        *last = false;
                    }
                    (true, true) => {
                        // This might be a "press" event, if sufficient time has passed - if so
                        // return the event, keeping in mind that we also need to store that we have
                        // now issued a press event - so no click event should be generated on button release.
                        if *is_press || millis - *last_time >= T_PRESS {
                            *is_press = true;
                            self.buffer[no_events] = ButtonEvent::Press {btn: i as Button, mods: Modifiers(mods), millis: millis - *last_time};
                            no_events += 1;
                        }
                    }
                }
           }
        }

        return &self.buffer[..no_events]
    }
}

impl Default for ButtonEvent {
    fn default() -> Self {
        Self::Click { btn: 0, mods: Modifiers(0) }
    }
}